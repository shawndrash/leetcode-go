# LeetCode Go 快速开始指南

## 📋 目录结构

```
leetcode-go/
├── README.md              # 项目说明文档
├── 快速开始指南.md         # 本文件
├── go.mod                 # Go 模块定义
├── Makefile              # 便捷命令集合
├── new_problem.sh        # 创建新题目脚本
├── problems/             # 所有题目
│   ├── 0001.two-sum/    # 第1题：两数之和
│   └── 0002.add-two-numbers/ # 第2题：两数相加
└── utils/                # 工具包
    ├── listnode.go       # 链表工具
    ├── treenode.go       # 树工具
    └── helpers.go        # 辅助函数
```

## 🚀 快速开始

### 1. 创建新题目

**方法一：使用脚本（推荐）**

```bash
./new_problem.sh 3 longest-substring "无重复字符的最长子串"
```

**方法二：使用 Makefile**

```bash
make new NUM=3 NAME=longest-substring CNAME="无重复字符的最长子串"
```

### 2. 编写解法

在生成的 `problems/0003.longest-substring/solution.go` 中编写代码：

```go
package longest_substring

// ============= 以下是提交到 LeetCode 的代码 =============

func lengthOfLongestSubstring(s string) int {
    // 你的解法实现
    return 0
}
```

💡 **注意**：标记下方的代码可以直接复制到 LeetCode 官网运行！

### 3. 编写测试

在 `solution_test.go` 中添加测试用例：

```go
func TestLengthOfLongestSubstring(t *testing.T) {
    tests := []struct {
        name string
        s    string
        want int
    }{
        {"示例1", "abcabcbb", 3},
        {"示例2", "bbbbb", 1},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := lengthOfLongestSubstring(tt.s)
            if got != tt.want {
                t.Errorf("got %v, want %v", got, tt.want)
            }
        })
    }
}
```

### 4. 运行测试

**测试单个题目：**

```bash
# 方法1：使用 Makefile
make test NUM=1

# 方法2：进入目录测试
cd problems/0001.two-sum
go test

# 方法3：从根目录测试
go test ./problems/0001.two-sum
```

**详细测试输出：**

```bash
make test-verbose NUM=1
```

**测试所有题目：**

```bash
make test-all
# 或
go test ./problems/...
```

### 5. 性能测试

**单个题目：**

```bash
make bench NUM=1
```

**所有题目：**

```bash
make bench-all
```

### 6. 查看测试覆盖率

```bash
make coverage NUM=1
```

### 7. 提交到 LeetCode

✅ **本地测试通过后，直接复制 `solution.go` 中标记的代码到 LeetCode！**

详见：[提交到LeetCode指南.md](./提交到LeetCode指南.md)

## 📦 使用工具包

**重要**：utils 工具包**只在测试文件中使用**，不在 solution.go 中使用！

### 在 solution.go 中

```go
package your_solution

// 链表题目：直接定义 ListNode
type ListNode struct {
    Val  int
    Next *ListNode
}

// ============= 以下是提交到 LeetCode 的代码 =============

func solution(head *ListNode) *ListNode {
    // 你的实现
    return head
}
```

### 在 solution_test.go 中使用 utils

```go
package your_solution

import (
    "testing"
    "github.com/shawndrash/leetcode-go/utils"
)

func TestSolution(t *testing.T) {
    // 使用 utils 工具构建测试数据
    utilsList := utils.BuildList([]int{1, 2, 3})

    // 转换为本地 ListNode 类型
    list := convertFromUtils(utilsList)

    // 测试
    result := solution(list)

    // 使用 utils 验证
    // ...
}
```

### 链表工具 (utils)

```go
// 创建链表: 1 -> 2 -> 3
list := utils.BuildList([]int{1, 2, 3})

// 链表转切片
slice := utils.ListToSlice(list)

// 比较两个链表
equal := utils.ListEqual(list1, list2)

// 打印链表（调试用）
utils.PrintList(list)
```

### 二叉树工具

```go
// 构建树（-1 表示 nil）
tree := utils.BuildTree([]int{1, 2, 3, -1, -1, 4, 5})

// 树转切片
slice := utils.TreeToSlice(tree)

// 比较两棵树
equal := utils.TreeEqual(tree1, tree2)

// 打印树结构
utils.PrintTree(tree)
```

### 辅助函数

```go
// 取最大/最小值
max := utils.Max(5, 10)
min := utils.Min(5, 10)

// 绝对值
abs := utils.Abs(-5)

// 切片比较
equal := utils.IntSliceEqual([]int{1,2}, []int{1,2})
```

## 🎯 常用命令

| 命令 | 说明 |
|------|------|
| `make help` | 显示所有可用命令 |
| `make test NUM=1` | 测试第1题 |
| `make test-verbose NUM=1` | 详细测试第1题 |
| `make test-all` | 测试所有题目 |
| `make bench NUM=1` | 性能测试第1题 |
| `make bench-all` | 性能测试所有题目 |
| `make coverage NUM=1` | 查看第1题覆盖率 |
| `make list` | 列出所有题目 |
| `make fmt` | 格式化代码 |
| `make clean` | 清理测试缓存 |

## 💡 项目特点

### ✅ 本地测试，直接提交

**最重要的特性**：本地测试通过后，代码可以直接复制到 LeetCode 官网运行，无需修改！

- solution.go 中直接定义数据结构，不依赖外部导入
- 只在测试文件中使用 utils 工具类
- 提交时只需复制函数部分

### ✅ 独立包结构，避免冲突

每道题使用独立的包名（如 `two_sum`），函数名不会冲突。

### ✅ 完整的测试支持

- 单元测试
- 性能基准测试
- 测试覆盖率分析

### ✅ 通用工具类

提供链表、树等常用数据结构的工具函数，**只用于测试**，避免重复代码。

### ✅ 自动化脚本

一键生成题目模板，包含：
- solution.go（解法文件，可直接提交）
- solution_test.go（测试文件，使用 utils）
- README.md（题目描述）

### ✅ Makefile 简化操作

无需记忆复杂命令，使用简单的 `make` 命令即可。

## 📝 命名规范

| 项目 | 格式 | 示例 |
|------|------|------|
| 目录名 | `0001.problem-name` | `0001.two-sum` |
| 包名 | `problem_name` | `two_sum` |
| 函数名 | 与 LeetCode 一致 | `twoSum` |

## 🔧 故障排除

### 测试无法运行

```bash
# 清理测试缓存
make clean

# 确保在正确的目录
cd /path/to/leetcode-go

# 检查 go.mod
go mod tidy
```

### 导入工具包失败

确保 `go.mod` 中的模块名正确：

```go
module github.com/shawn/leetcode-go
```

## 📚 示例题目

项目包含两个完整的示例：

1. **0001.two-sum** - 演示基本用法
2. **0002.add-two-numbers** - 演示如何使用链表工具

可以参考这些示例来编写自己的解法。

## 🎓 最佳实践

1. **一题一包**：每道题独立包，避免冲突
2. **先写测试**：TDD 方式，先写测试用例
3. **多种解法**：可以在同一个文件中实现多种解法对比
4. **性能测试**：使用 Benchmark 测试性能
5. **详细注释**：添加时间/空间复杂度注释

## 📖 参考资源

- [LeetCode 中国](https://leetcode.cn/)
- [Go 测试文档](https://golang.org/pkg/testing/)
- [Go Benchmark 指南](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)

---

**祝你刷题愉快！🎉**

